<div class="navbar d-flex top align-center">
    <button *ngIf="(ui$|async).collapsedMenu" class="btn icon invert-on-dark icon" (click)="toggleSidebar()">
        <svg height="16px" viewBox="0 0 16 16" width="16px" xmlns="http://www.w3.org/2000/svg">
            <g fill="fillColor">
                <path d="m 1 2 h 14 v 2 h -14 z m 0 0"/>
                <path d="m 1 7 h 14 v 2 h -14 z m 0 0"/>
                <path d="m 1 12 h 14 v 2 h -14 z m 0 0"/>
            </g>
        </svg>
    </button>
    <span class="brand flex-grow">Chatta with mbare</span>
</div>
<div class="pad-2">
    <h1 style="margin-top: .5rem;" id="chatta-with-mbare">Chatta with mbare</h1>
    <p>Chatta with mbare is a web chat and video call application, made with Angular and NodeJS, made for a university assignment for Web Programming, Design and Usability course.</p>
    <h2 id="application-design">Application design</h2>
    <p>This application follows the client-server pattern, with NodeJS providing services such as websockets communications and message dispatching, and the client providing the interface the users would use to chat and videocall with their fellas;<br>
    furthermore, as I love the concept of actions provided by NgRx and Redux, I chose this concept both on client and server, the server is indeed a dispatcher of messages, the sessions just listens to their inbound messages or public events, while they can dispatch other messages to other clients, but resulted in a nightmare 'cos I haven’t provided a clear separation of server and client actions.</p>
    <h3 id="server-design">Server design</h3>
    <p>The server uses SocketIO to provide both manageable websocket connections, expressjs to provide static resources such as the client and user pictures and a single real GET call to get a list of ‘em.<br>
    Each connection via websockets goes through the SessionManager, as the user provides its own uuid, it just checks if it is connected, if not create a new Session which proxies actions between the global server’ dispatcher and the client itself, once the connection get lost or closed, SessionManager disposes Session.<br>
    Server does not store any info about users.</p>
    <h3 id="client-design">Client design</h3>
    <p>The client is made with Angular to provide a comfy UI and just 'cos I have been working with it these last 5 years I got addicted and forgot how to work without it; the style is inspired by GNOME’s borderless mocks.<br>
    It uses NgRx to provide states and side-effects, Dexie to store messages and pals so you can write to them even when not connected ( provided you both will be online at some point ); SocketIO-client to bridge events from servers to client and viceversa; PeerJS handles streaming calls, sadly this would connect to their own server as it is incompatible with SocketIO in the backend.</p>
    <h3 id="issues-encountered.">Issues encountered.</h3>
    <ol>
    <li>This is the first time I make a video call application and didn’t know where to start.</li>
    <li>I tried to use RxDB to provide storage, it is usually great with Angular, albeit it has bad perfs and documentation, this time it was so frustating, I had to search for alternatives, Dexie came in yet it does not have live queries.</li>
    <li>Mobile devices have incorrect viewport units, ALL OF THEM, 'cos they do not take in account their navigation bar, this trick saved the day: <a href="https://css-tricks.com/the-trick-to-viewport-units-on-mobile/">https://css-tricks.com/the-trick-to-viewport-units-on-mobile/</a>.</li>
    <li>Unnecessary large project hell, as I could easily follow a PeerJS+SocketIO tutorial and get away with it.</li>
    <li>PeerJS and SocketIO do not like each other, you cannot have both of them in the same port.</li>
    <li>Angular doesn’t updates UI if source’s not gone through NgZone, made a pipe for under client’s <code>src/utils</code>, this happens when say instantiate a non angular related class that provides Observables or Promises, they aren’t tracked by the async pipe.</li>
    <li>Call management is hell, I had rewritten it at least 6 times, 'cos you have you and your pal, sharing a stream and then one of you wants to stream your screen, so a new call must be made. As a side note, I found this by Mozilla <a href="https://blog.mozilla.org/webrtc/warm-up-with-replacetrack/">https://blog.mozilla.org/webrtc/warm-up-with-replacetrack/</a> which helped a lot, TL;DR; you always start a complete stream with video+audio, but content is dummy, tracks are replaced as you request or unrequest mic or webcam use with dummy ones or viceversa.</li>
    <li>Angular lazy loading would not load a lazy’s lazy child: one trick I used to make call and answer, is to guard both <code>/app/avchat/answer/:uuid</code> and <code>/app/avchat/call/:uuid</code> , when you try to call your pal, the client tries to navigate to the latter, and fires the guard which waits for pal’s answer, but pal’s must be redirected by a session’s event, and <code>router.navigate(['/app/avchat/answer',caller])</code> didn’t work at all, so I thought I could redirect from <code>RootModule</code>'s router, which is parent of <code>CallModule</code>, to its child with <code>redirect: 'url...'</code>, and then it worked.</li>
    
    </ol>
    <h1 id="build-me-plz">Build me plz</h1>
    <p>git clone this repo, then by cli go under app and write  <code>npm i</code>, then <code>npm run build</code>, these commands will install some gigs of deps for angular and build the client under <code>server/static/client</code>, then change dir to server, run <code>npm i</code> again, then <code>node index</code> and you are good to go, server is hosted by default at <code>0.0.0.0:8080</code>.</p>
    
</div>
